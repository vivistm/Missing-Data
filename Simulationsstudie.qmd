---
title: "Simulationsstudie"
format: html
editor: visual
---

```{r}
#| echo: false
pacman::p_load("VIM","rgl","MASS","tidyverse","mice")
```

## Code von Julius Simulationsstudie wie bei Julius

Wir brauchen mindestens eine Variable mehr als die transformierte X\^2 um MAR erzeugen zu können.

Da der Text sich zu erst mit X\^2 beschäftigt, glaube ich dass es sinnvoll ist das ebenfalls zu tun

X3 ist die transformierte Variable X2\^2

Notwendigkeit von Widerholung damit Simulationsstudie

Daten generieren
```{r}
set.seed(1)
  
n <- 10000
X1 <- rnorm(n, 8, 3) # Prädiktor für X2,X3, Y
X2 <- rnorm(n, 0, 3) # weitere Variable damit MAR erzeugt werden kann
X3 <- X2^2 # transformierte Variable
Y <- 5 + 0.6 * X1 + 0.5 * X2 + 0.3*X3+ rnorm(n, 0, sqrt(2)) # Outcome Variable
  
data1 <- as.data.frame(cbind(X1, X2, X3, Y))
  
  # Quantities of interest for the original data set
(bef.Imp2 <- cbind(mean = mean(X2), # Überlegen ob ich Mean brauche oder den True Mean den ich in die Daten gebe
                    var = var(X2)))
  
(bef.Imp3 <- cbind(mean = mean(X3),
                     var = var(X3)))
  
X2NonNA <- X2 # save for later
X3NonNA <- X3 # save for later
  
# Generate missing values (MCAR)
data1$X2[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
data1$X3[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  
# Missing indicators for missing data in X3
misind2 <- is.na(data1$X2)
misind3 <- is.na(data1$X3)
# Indicators for observed (not missing) data in X3
obsind2 <- !is.na(data1$X2)
obsind3 <- !is.na(data1$X3)
  
  
#layout(matrix(c(1,2,2), nrow=1))
barMiss(data1,pos = 4) 
# pos- Argument spezifiziert welche Variable betrachtet wird
marginplot(data1[, c("X2", "Y")])
marginplot(data1[, c("X3", "Y")])
```

# Impute than transform von Julius

irgendwas funktioniert noch nicht so wie es sollte

```{r}
imp <- mice(data1, print = FALSE, seed = 7112)
com_data1 <- complete(imp, "long", include = TRUE)
com_data1 $X3 <- with(com_data1 , X2^2)

# Wir brauchen nur transformierte Daten
imp_data1 <- 
  com_data1  %>% filter(.imp == 1)


# Bias untersuchen
(after.Imp2 <- cbind(mean = mean(imp_data1$X2),
                    var = var(imp_data1$X2)))

(after.Imp3 <- cbind(mean = mean(imp_data1$X3),
                    var = var(imp_data1$X3)))
bias_2 <- after.Imp2[,"mean"]-bef.Imp2[,"mean"]
bias_3 <- after.Imp3[,"mean"]-bef.Imp3[,"mean"]

# MSE
mse_2 <- (after.Imp2[,"mean"]-bef.Imp2[,"mean"])^2
mse_3 <- (after.Imp3[,"mean"]-bef.Imp3[,"mean"])^2

#imp.itt <- as.mids(imp_data1)   # Converts an imputed dataset (long format) into a mids object


  
# -> transformed variable cannot be used for imputation..

#

#plot the imputed values
long_Imp1 <- 
  long %>% filter(.imp == 1) %>% # gefiltert weil imp == 1 imputierte daten sind
  mutate("X2" = imp$where[,2],
         "X3" = imp$where[,3])# %>% 
 # mutate("X3_imp" = imp$whereX)
marginplot(x = long_Imp1[,c("X2","X3")], delimiter = "_imp")

marginplot(x = long_Imp1[,c("X2","X3","X3_imp")], delimiter = "_imp")




```

# Transform than Impute von Julius

```{r}
data1$X3 <- data1$X2^2

imp.jav1 <- mice(data, seed = 32093, print = FALSE)
pred <- make.predictorMatrix(data)
pred

# set relevant entries to 0 to prevent automatic removal
pred[c("wgt", "whr"), c("wgt", "whr")] <- 0
pred[c("hgt", "whr"), c("hgt", "whr")] <- 0
pred

imp.jav2 <- mice(data, pred = pred, seed = 32093, print = TRUE)
```

# Mit Wiederholungen
```{r}

S <- 10
n <- 100

MeanVec2 <- MeanVec3 <- BiasVec2 <- BiasVec3 <- UpperBoundVec <- LowerBoundVec <- MSEVec2 <- MSEVec3 <- numeric(S)
for (s in 1:S) {
  # Daten erzeugen
  X1 <- rnorm(n, 8, 3) # Prädiktor für X2,X3, Y
  X2 <- 10 - 0.5 * X1 + rnorm(n, 0, 3) # weitere Variable damit MAR erzeugt werden   kann
  X3 <- X2^2 # transformierte Variable
  Y <- 5 + 0.6 * X1 + 0.5 * X2 + 0.3*X3+ rnorm(n, 0, sqrt(2)) # Outcome Variable
  
    # Quantities of interest for the original data set
  (bef.Imp2 <- cbind(mean = mean(X2),
                    var = var(X2)))
  
  (bef.Imp3 <- cbind(mean = mean(X3),
                     var = var(X3)))
  
  # Generate missing values (MCAR)
  data1$X2[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  data1$X3[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  # Impute, than transform
  imp <- mice(data1, print = FALSE, seed = 7112)
  com_data1 <- complete(imp, "long", include = TRUE)
  com_data1 $X3 <- with(com_data1 , X2^2)
  
  # Wir brauchen nur transformierte Daten
  imp_data1 <- 
  com_data1  %>% filter(.imp == 1)


  # Bias untersuchen
  (after.Imp2 <- cbind(mean = mean(imp_data1$X2),
                      var = var(imp_data1$X2)))
  
  (after.Imp3 <- cbind(mean = mean(imp_data1$X3),
                      var = var(imp_data1$X3)))
  MeanVec2[s] <- after.Imp2[,"mean"]
  MeanVec3[s] <- after.Imp3[,"mean"]
  BiasVec2[s] <- after.Imp2[,"mean"]-bef.Imp2[,"mean"]
  BiasVec3[s] <- after.Imp3[,"mean"]-bef.Imp3[,"mean"]
  
  # MSE
  MSEVec2[s] <- (after.Imp2[,"mean"]-bef.Imp2[,"mean"])^2
  MSEVec3[s] <- (after.Imp3[,"mean"]-bef.Imp3[,"mean"])^2
  
  #calculate bounds of interval 
  UpperBoundVec[s] <- MeanVec2[s] + 1.96 * 1 / sqrt(n) 
  LowerBoundVec[s] <- MeanVec2[s] - 1.96 * 1 / sqrt(n)
  
}

TotDat <- cbind("It" = 1:S,
                "TrueVal"=3,
                 MeanVec2, MeanVec3,BiasVec2, BiasVec3,UpperBoundVec, LowerBoundVec,MSEVec2,MSEVec3)

```

The `echo: false` option disables the printing of code (only output is displayed).
