---
title: "Aktuelleste Fassung"
author: "Vivian"
format: html
editor: visual
---
Aktuellste Gedanken/Ideen:

- Regression gemacht jetzt müssen noch die True Values Aktualisieren und die Funktion so umschreiben, dass wir das nicht nur für X3 machen
- Coverage funktioniert gut, Bias blicke ich noch nicht so durch (müsste ich auch berechnet haben nur wo ist die Auswertung)
- daher siehe Code in Simulationsstudie vor allem Combining Rules beachten (keine Ahung was da abgeht)


```{r}
#| echo: false
pacman::p_load("VIM","rgl","MASS","tidyverse","mice")
```
# Patterns
```{r}
set.seed(1)
  
n <- 10000
X1 <- rnorm(n, 8, 3) # Prädiktor für X2,X3, Y
X2 <- rnorm(n, 0, 3) # weitere Variable damit MAR erzeugt werden kann
X3 <- X2^2 # transformierte Variable
Y <- 5 + 0.6 * X1 + 0.5 * X2 + 0.3*X3+ rnorm(n, 0, sqrt(2)) # Outcome Variable
  
data1 <- as.data.frame(cbind(X1, X2, X3, Y))
  
  # Quantities of interest for the original data set
(bef.Imp2 <- cbind(mean = mean(X2), # Überlegen ob ich Mean brauche oder den True Mean den ich in die Daten gebe
                    var = var(X2)))
  
(bef.Imp3 <- cbind(mean = mean(X3),
                     var = var(X3)))

# Generate missing values (MCAR)
data1$X2[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
data1$X3[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA

# Pattern
md.pattern(data1)
VIM::aggr(data1)
marginplot(data1[, c("X2", "Y")])
marginplot(data1[, c("X3", "Y")])
```
#Impute, than transform mit Wiederholungen 
- Bias, MSE, Lower and Upperbound von Konfidenzintervallen - Coverage - CI- range könnte man noch machen

```{r}
set.seed(123) # Seed für Reproduzierbarkeit
S <- 200 # Anzahl der Simulationen
n <- 50 # Stichprobengröße
M <- 5

# Vektoren initialisieren
TrueMeanVec2 <- numeric(S)
TrueMeanVec3 <- numeric(S)
ImpMeanVec2 <- numeric(S)
ImpMeanVec3 <- numeric(S)
BiasVec2 <- numeric(S)
BiasVec3 <- numeric(S)
MSEVec2 <- numeric(S)
MSEVec3 <- numeric(S)
UpperBoundVec2 <- numeric(S)
LowerBoundVec2 <- numeric(S)
UpperBoundVec3 <- numeric(S)
LowerBoundVec3 <- numeric(S)

for (s in 1:S) {
  X1 <- rnorm(n, 8, 3)
  X2 <- 10 - 0.5 * X1 + rnorm(n, 0, 3)
  X3 <- X2^2
  Y <- 5 + 0.6 * X1 + 0.5 * X2 + 0.3 * X3 + rnorm(n, 0, sqrt(2))
  
  bef.Imp2 <- cbind(mean = mean(X2), var = var(X2))
  bef.Imp3 <- cbind(mean = mean(X3), var = var(X3))
  
  data1 <- as.data.frame(cbind(X1, X2, X3, Y))
  data1$X2[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  data1$X3[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  
  imp <- mice(data1, print = FALSE, seed = s, m = 5)
  com_data1 <- complete(imp, "long", include = TRUE)
  com_data1$X3 <- with(com_data1, X2^2)
  imp_data1 <- com_data1[com_data1$.imp == M, ]
  
  after.Imp2 <- cbind(mean = mean(imp_data1$X2), var = var(imp_data1$X2))
  after.Imp3 <- cbind(mean = mean(imp_data1$X3), var = var(imp_data1$X3))
  
  TrueMeanVec2[s] <- bef.Imp2[,"mean"]
  TrueMeanVec3[s] <- bef.Imp3[,"mean"]
  ImpMeanVec2[s] <- after.Imp2[,"mean"]
  ImpMeanVec3[s] <- after.Imp3[,"mean"]
  BiasVec2[s] <- after.Imp2[,"mean"] - bef.Imp2[,"mean"]
  BiasVec3[s] <- after.Imp3[,"mean"] - bef.Imp3[,"mean"]
  MSEVec2[s] <- (after.Imp2[,"mean"] - bef.Imp2[,"mean"])^2
  MSEVec3[s] <- (after.Imp3[,"mean"] - bef.Imp3[,"mean"])^2
  UpperBoundVec2[s] <- ImpMeanVec2[s] + 1.96 * sqrt(after.Imp2[,"var"]) / sqrt(n)
  LowerBoundVec2[s] <- ImpMeanVec2[s] - 1.96 * sqrt(after.Imp2[,"var"]) / sqrt(n)
  UpperBoundVec3[s] <- ImpMeanVec3[s] + 1.96 * sqrt(after.Imp3[,"var"]) / sqrt(n)
  LowerBoundVec3[s] <- ImpMeanVec3[s] - 1.96 * sqrt(after.Imp3[,"var"]) / sqrt(n)

}



TotDat <- data.frame(
  "Iteration" = 1:S,
  TrueMeanVec2, ImpMeanVec2, TrueMeanVec3, ImpMeanVec3,
  BiasVec2, BiasVec3, UpperBoundVec3, LowerBoundVec3,
  MSEVec2, MSEVec3, UpperBoundVec2, LowerBoundVec2
)
head(TotDat)
class(TotDat)


Conf_Inter_2 <- TotDat  %>% filter( Iteration < 101) %>% 
  ggplot(aes(x = Iteration)) +
  geom_errorbar(aes(ymin = UpperBoundVec2, ymax = LowerBoundVec2)) +
  geom_point(aes(y   = TrueMeanVec2), col = "#593196")+
  theme_bw()

Conf_Inter_3 <- TotDat  %>% filter( Iteration < 101) %>% 
  ggplot(aes(x = Iteration)) +
  geom_errorbar(aes(ymin = UpperBoundVec3, ymax = LowerBoundVec3)) +
  geom_point(aes(y = TrueMeanVec3), col = "#593196")+
  theme_bw()

colMeans(TotDat)

TotDat$CIrange2 <- UpperBoundVec2-LowerBoundVec2
TotDat$CIrange3 <-UpperBoundVec3-LowerBoundVec3

# Coverage
Coverage2 <- TotDat  %>% 
  summarise("Coverage2" = mean((LowerBoundVec2 <= TrueMeanVec2 & UpperBoundVec2 >= TrueMeanVec2)))

# Coverage 2 liegt bei 1, dass finde ich schon krass

Coverage3 <- TotDat %>% 
  summarise("Coverage3" = mean((LowerBoundVec3<= TrueMeanVec3 & UpperBoundVec3 >= TrueMeanVec3)))



```

```{r}
set.seed(123) # Seed für Reproduzierbarkeit
S <- 200 # Anzahl der Simulationen
n <- 50 # Stichprobengröße
M <- 5


# functions for diagnostics:
calc_coverage <- function(value, CI_low, CI_upper) {
  (CI_low <= value & CI_upper >= value)
}

calc_rel_bias <- function(value, est) {
  rel_bias <- (est - value) / value
  return(rel_bias)
}

meanDiag <- function(data, alpha=0.05, trueValue,...) {
  #Estimation of mean and CI
    mean.X3 <- mean(data$X3, na.rm=TRUE)
    CI.low <- mean.X3 - qnorm(1-alpha/2)*sqrt(var(data$X3,na.rm=TRUE)/sum(!is.na(data$X3)))
    CI.hi <- mean.X3 + qnorm(1-alpha/2)*sqrt(var(data$X3,na.rm=TRUE)/sum(!is.na(data$X3)))
    
    #Calculation of coverage
    coverage <- calc_coverage(value = trueValue, 
                              CI_low = CI.low, 
                              CI_upper = CI.hi) 
    #calculation of Bias
    relbias <- calc_rel_bias(value = trueValue, est = mean.X3)

    
    Imp <- data.frame("Param" = "mu3",
                      "meanVal"= mean.X3, 
                     "in-PI"= coverage, 
                     "relBias" = relbias)
    
    return(Imp)
}

# Funktion ohne quadratischer Term
paramDiag <- function(data, alpha=0.05, trueValue,...) {
  
  #caclulation of linear model
    model <- lm(Y~X1+X2+X3, data=data, na.action = "na.omit")
    
    #get parameters
    beta.hat <- model$coefficients
    se.beta.hat <- summary(model)$coefficients[ ,2]
    
    #calculate CI of beta parameters
    CI.low <- beta.hat - qnorm(1-alpha/2)*se.beta.hat
    CI.hi <- beta.hat + qnorm(1-alpha/2)*se.beta.hat
    
    coverage <- calc_coverage(value = trueValue, CI_low = CI.low, CI_upper = CI.hi) 
    
    relbias <- calc_rel_bias(value = trueValue, est = beta.hat)
    
    Ret <- data.frame("Param" = c("b0","b1","b2","b3"),
                      "meanVal"= beta.hat,
                      "in-PI" = coverage,
                      "relBias" = relbias)
    
    rownames(Ret) <- NULL
    
    return(Ret)
    
}

ImpBD <- vector("list", S)
ImpAI <- vector("list", S)


for (s in 1:S) {
  X1 <- rnorm(n, 8, 3)
  X2 <- 10 - 0.5 * X1 + rnorm(n, 0, 3)
  X3 <- X2^2
  Y <- 5 + 0.6 * X1 + 0.5 * X2 + 0.3 * X3 + rnorm(n, 0, sqrt(2))
  
  data1 <- as.data.frame(cbind(X1, X2, X3, Y))
  data1$X2[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  data1$X3[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  
  imp <- mice(data1, print = FALSE, seed = s, m = 5)
  com_data1 <- complete(imp, "long", include = TRUE)
  com_data1$X3 <- with(com_data1, X2^2)
  imp_data1 <- com_data1[com_data1$.imp == M, ]
  
  #1.) Calculate Mean, CI and Bias of X3 variable
  data1.m <- meanDiag(data1,trueValue = 47.25)
  imp_data1.m <- meanDiag(imp_data1,trueValue = 47.25)
  
  #2.) Calculate beta values, CI and rel Bias 
    data1.p<- paramDiag(data1, trueValue = c(5,0.6,0.5,0.3), alpha = 0.05)      
  imp_data1.p <- paramDiag(imp_data1, trueValue = c(5,0.6,0.5,0.3), alpha = 0.05)

  ImpBD[[s]] <- rbind(data1.m,       # save results for the i-th BD dataset
                        data1.p)

  ImpAI[[s]] <- rbind(imp_data1.m,      # save results for the i-th SR dataset
                        imp_data1.p)
}

 
ImpAI[[1]]

```
# Ergebnisse

```{r}
LongResultBD <- ImpBD %>% 
                bind_rows() %>% 
                mutate(Param  = factor(Param, 
                                       level = unique(Param),
                                       labels = c(expression(mu[3]),
                                                  expression(beta[0]),
                                                  expression(beta[1]),
                                                  expression(beta[2]),
                                                  expression(beta[3])))) %>% 
                group_by(Param) %>% 
                mutate("Type"="BeforeDeletion") 
                

LongResultSR <- ImpAI %>% 
                bind_rows() %>% 
                mutate(Param  = factor(Param, 
                                       level = unique(Param),
                                       labels = c(expression(mu[3]),
                                                  expression(beta[0]),
                                                  expression(beta[1]),
                                                  expression(beta[2]),
                                                  expression(beta[3])))) %>% 
                group_by(Param) %>% 
                mutate("Type"="MI pmm")


CoverageBD <- LongResultBD %>% 
              summarise("Coverage"=mean(in.PI)) %>% 
              mutate("Type"="BeforeDeletion")

CoverageSR <- LongResultSR %>% 
              summarise("Coverage"=mean(in.PI)) %>% 
              mutate("Type"="MI pmm")
```

# Variablen und True Values fixen
```{r}
set.seed(123) # Seed für Reproduzierbarkeit
S <- 200 # Anzahl der Simulationen
n <- 50 # Stichprobengröße
M <- 5 # Anzahl der Imputationen


# functions for diagnostics:
calc_coverage <- function(value, CI_low, CI_upper) {
  (CI_low <= value & CI_upper >= value)
}

calc_rel_bias <- function(value, est) {
  rel_bias <- (est - value) / value
  return(rel_bias)
}

meanDiag <- function(data, alpha=0.05, trueValue, variable,...) {
  #Estimation of mean and CI
    mean.X3 <- mean(data$variable, na.rm=TRUE)
    CI.low <- mean.X3 - qnorm(1-alpha/2)*sqrt(var(data$X3,na.rm=TRUE)/sum(!is.na(data$X3)))
    CI.hi <- mean.X3 + qnorm(1-alpha/2)*sqrt(var(data$X3,na.rm=TRUE)/sum(!is.na(data$X3)))
    
    #Calculation of coverage
    coverage <- calc_coverage(value = trueValue, 
                              CI_low = CI.low, 
                              CI_upper = CI.hi) 
    #calculation of Bias
    relbias <- calc_rel_bias(value = trueValue, est = mean.X3)

    
    Imp <- data.frame("Param" = "mu3",
                      "meanVal"= mean.X3, 
                     "in-PI"= coverage, 
                     "relBias" = relbias)
    
    return(Imp)
}

# Funktion ohne quadratischer Term
paramDiag <- function(data, alpha=0.05, trueValue,...) {
  
  #caclulation of linear model
    model <- lm(Y~X1+X2+X3, data=data, na.action = "na.omit")
    
    #get parameters
    beta.hat <- model$coefficients
    se.beta.hat <- summary(model)$coefficients[ ,2]
    
    #calculate CI of beta parameters
    CI.low <- beta.hat - qnorm(1-alpha/2)*se.beta.hat
    CI.hi <- beta.hat + qnorm(1-alpha/2)*se.beta.hat
    
    coverage <- calc_coverage(value = trueValue, CI_low = CI.low, CI_upper = CI.hi) 
    
    relbias <- calc_rel_bias(value = trueValue, est = beta.hat)
    
    Ret <- data.frame("Param" = c("b0","b1","b2","b3"),
                      "meanVal"= beta.hat,
                      "in-PI" = coverage,
                      "relBias" = relbias)
    
    rownames(Ret) <- NULL
    
    return(Ret)
    
}

ImpBD <- vector("list", S)
ImpAI <- vector("list", S)


for (s in 1:S) {
  X1 <- rnorm(n, 8, 3)
  X2 <- 10 - 0.5 * X1 + rnorm(n, 0, 3)
  X3 <- X2^2
  Y <- 5 + 0.6 * X1 + 0.5 * X2 + 0.3 * X3 + rnorm(n, 0, sqrt(2))
  
  data1 <- as.data.frame(cbind(X1, X2, X3, Y))
  data1$X2[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  data1$X3[sample(x = 1:n, size = n/2, replace = FALSE)] <- NA
  
  imp <- mice(data1, print = FALSE, seed = s, m = 5)
  com_data1 <- complete(imp, "long", include = TRUE)
  com_data1$X3 <- with(com_data1, X2^2)
  imp_data1 <- com_data1[com_data1$.imp == M, ]
  
  #1.) Calculate Mean, CI and Bias of X3 variable
  data1.m <- meanDiag(data1,trueValue = 47.25)
  imp_data1.m <- meanDiag(imp_data1,trueValue = 47.25)
  
  #2.) Calculate beta values, CI and rel Bias 
    data1.p<- paramDiag(data1, trueValue = c(5,0.6,0.5,0.3), alpha = 0.05)      
  imp_data1.p <- paramDiag(imp_data1, trueValue = c(5,0.6,0.5,0.3), alpha = 0.05)

  ImpBD[[s]] <- rbind(data1.m,       # save results for the i-th BD dataset
                        data1.p)

  ImpAI[[s]] <- rbind(imp_data1.m,      # save results for the i-th SR dataset
                        imp_data1.p)
}

 
ImpAI[[1]]

```


```{r}
meanDiag <- function(data, alpha=0.05, trueValue, variable,...) {
  #Estimation of mean and CI
    mean.v <- mean(data[variable], na.rm=TRUE)
    CI.low <- mean.v - qnorm(1-alpha/2)*sqrt(var(data[variable],na.rm=TRUE)/sum(!is.na(data[[variable]])))
    CI.hi <- mean.v + qnorm(1-alpha/2)*sqrt(var(data[variable]],na.rm=TRUE)/sum(!is.na(data[[variable]])))
    
    #Calculation of coverage
    coverage <- calc_coverage(value = trueValue, 
                              CI_low = CI.low, 
                              CI_upper = CI.hi) 
    #calculation of Bias
    relbias <- calc_rel_bias(value = trueValue, est = mean.v)

    
    Imp <- data.frame("Param" = "mu3",
                      "meanVal"= mean.v, 
                     "in-PI"= coverage, 
                     "relBias" = relbias)
    
    return(Imp)
}
meanDiag(data1,trueValue = 6,variable = X2)

data1$X2
```