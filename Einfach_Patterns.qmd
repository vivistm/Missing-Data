---
title: "Einfache Patterns"
format: html
editor: visual
---

# Patterns erzeugt

-   Outline hilfreich

Daten, die erzeugt werden
- data_sqrt_m(c)ar 
- data_inter_m(c)ar 
- data_sinus_m(c)ar

# Packages laden

```{r}
#| echo: false
pacman::p_load("VIM","rgl","MASS","tidyverse","mice","MASS")
```

# Quadratisch

```{r}
set.seed(42)

# 4 variables: 
p <- 4  
# 3000 observations:
n <- 3000

# draw expected values:
mu <- (runif(p,-1,5))
mu

A <- matrix(rnorm(p^2), p, p)  # Zufällige Matrix
A <- t(A) %*% A             # Positive definite Matrix
V <- cov2cor(A)           # Korrelationmatrix

# Datenframe
x_df_org <- mvrnorm(n, mu, V) %>% data.frame()
names(x_df_org) <- paste0("x_", 1:4)
x_df_org$x1_squared <- x_df_org[, 1]^2 # transformiert
mu[p+1] <- mu[1]^2

true_beta <- c(1, 1.5, -0.8, 0.5, 0.2,0.4)  # c(intercept, b1,b2,b3,b4,b5(beta für interaktion))
E_Y <- mu%*%true_beta[2:(p+2)]+true_beta[1] # Analytische Erwartungswerte

# Empirische Y Werte
x_matrix_org <- as.matrix(x_df_org)
X_full <- cbind(1, x_matrix_org)  # Intercept hinzufügen

Y <- X_full %*% true_beta + rnorm(n,0,1)
data_sqrt<- cbind(x_df_org,Y)

# Zusammenfassend
true_beta
mu
E_Y
data_sqrt

mu
```

## MCAR

```{r}
data_sqrt_mcar <- data_sqrt

data_sqrt_mcar$x_1[sample(x = 1:n, size = n*0.3, replace = FALSE)] <- NA

# Missingness bei x_1 squard durch NAs die Missing in x1 sind
data_sqrt_mcar$x1_squared <- data_sqrt_mcar$x_1^2

VIM::aggr(data_sqrt_mcar)
```

## MAR

-   Lineare REgression

```{r}
data_sqrt_mar <- data_sqrt
# Berechnung des fehlenden Mechanismus (MAR)
miss_obs_x1 <- 0.5 + 2 * data_sqrt_mar$x_2 - 0.7 * data_sqrt_mar$x_3 + rnorm(n, 0, 3)

# Logischer Vektor für fehlende Werte
mis_mar_p <- miss_obs_x1 < quantile(miss_obs_x1, 0.3)

# Zuweisung von NA in x_1
data_sqrt_mar$x_1[mis_mar_p] <- NA

# Missingness bei x_1 squard durch NAs die Missing in x1 sind
data_sqrt_mar$x1_squared <- data_sqrt_mar$x_1^2

VIM::aggr(data_sqrt_mar)
```

# Interaktion (X1\*X3)

```{r}
set.seed(12345)

# 4 variables: 
p <- 4  
# 3000 observations:
n <- 3000

# draw expected values:
mu <- (runif(p,-1,5))
mu

A <- matrix(rnorm(p^2), p, p)  # Zufällige Matrix
A <- t(A) %*% A             # Positive definite Matrix
V <- cov2cor(A)           # Korrelationmatrix

# Datenframe
x_df_org <- mvrnorm(n, mu, V) %>% data.frame()
names(x_df_org) <- paste0("x_", 1:4)
x_df_org$interaktion <- x_df_org[, 1]*x_df_org[,3] # transformiert
mu[p+1] <- mu[1]*mu[3]

true_beta <- c(1, 1.5, -0.8, 0.5, 0.2,0.4)  # c(intercept, b1,b2,b3,b4,b5(beta für interaktion))
E_Y <- mu%*%true_beta[2:(p+2)]+true_beta[1] # Analytische Erwartungswerte

# Empirische Y Werte
x_matrix_org <- as.matrix(x_df_org)
X_full <- cbind(1, x_matrix_org)  # Intercept hinzufügen

Y <- X_full %*% true_beta + rnorm(n,0,1)
data_inter<- cbind(x_df_org,Y)

# Zusammenfassend
true_beta
mu
E_Y
data_inter
```

## MCAR

```{r}
data_inter_mcar <- data_inter
data_inter_mcar$x_1[sample(x = 1:n, size = n*0.3, replace = FALSE)] <- NA
data_inter_mcar$interaktion <- data_inter_mcar$x_1*data_inter_mar$x_3

```

## MAR

```{r}
data_inter_mar <- data_inter
# Berechnung des fehlenden Mechanismus (MAR)
miss_obs_x1 <- 0.5 + 2 * data_inter_mar$x_2 - 0.7 * data_inter_mar$x_3 + rnorm(n, 0, 3)

# Logischer Vektor für fehlende Werte
mis_mar_p <- miss_obs_x1 < quantile(miss_obs_x1, 0.3)

# Zuweisung von NA in x_1
data_inter$x_1[mis_mar_p] <- NA

# Missingness bei x_1 squard durch NAs die Missing in x1 sind
data_inter_mar$interaktion <- data_inter_mar$x_1*data_inter_mar$x_3

VIM::aggr(data_inter_mar)
```

# Sinus

```{r}
set.seed(12345)

# 4 variables: 
p <- 4  
# 3000 observations:
n <- 3000

# draw expected values:
mu <- (runif(p,-1,5))
mu

A <- matrix(rnorm(p^2), p, p)  # Zufällige Matrix
A <- t(A) %*% A             # Positive definite Matrix
V <- cov2cor(A)           # Korrelationmatrix

# Datenframe
x_df_org <- mvrnorm(n, mu, V) %>% data.frame()
names(x_df_org) <- paste0("x_", 1:4)
x_df_org$sinus <- sin(x_df_org[, 1]) # transformiert
mu[p+1] <- sin(mu[1])

true_beta <- c(1, 1.5, -0.8, 0.5, 0.2,0.4)  # c(intercept, b1,b2,b3,b4,b5(beta für interaktion))
E_Y <- mu%*%true_beta[2:(p+2)]+true_beta[1] # Analytische Erwartungswerte

# Empirische Y Werte
x_matrix_org <- as.matrix(x_df_org)
X_full <- cbind(1, x_matrix_org)  # Intercept hinzufügen

Y <- X_full %*% true_beta + rnorm(n,0,1)
data_sinus<- cbind(x_df_org,Y)

# Zusammenfassend
true_beta
mu
E_Y
data_sinus
```

##MCAR

```{r}
data_sinus_mcar <- data_sinus
pos_na <- sample(x = 1:n, size = n*0.3, replace = FALSE)
data_sinus_mcar$x_1[pos_na] <- NA
data_sinus_mcar$sinus[pos_na] <- NA
```

##MAR

```{r}
data_sinus_mar <- data_sinus
# Berechnung des fehlenden Mechanismus (MAR)
miss_obs_x1 <- 0.5 + 2 * data_sinus_mar$x_2 - 0.7 * data_sinus_mar$x_3 + rnorm(n, 0, 3)

# Logischer Vektor für fehlende Werte
mis_mar_p <- miss_obs_x1 < quantile(miss_obs_x1, 0.3)

# Zuweisung von NA in x_1
data_sinus_mar$x_1[mis_mar_p] <- NA
data_sinus_mar$sinus[mis_mar_p] <- NA

VIM::aggr(data_sinus_mar)

```
